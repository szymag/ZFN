>From 43fd07d7e3bb6d8dcf6339c5a8d7a71b97b71560 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=C5=81ukasz=20Hryniuk?= <lukasz.hryniuk@wp.pl>
Date: Sat, 25 Feb 2017 15:35:27 +0100
Subject: [PATCH] Add code review

---
 poczatek.py                                        |  5 +++--
 src/drawing/Dispersion_graph.py                    | 17 ++++++++++++++-
 src/drawing/PlotTM.py                              | 11 +++++++++-
 src/drawing/test.py                                | 15 +++++++++++--
 src/eig_problem/DFT.py                             | 16 ++++++++++++++
 src/eig_problem/FFTfromFile.py                     |  1 +
 src/eig_problem/MacierzDoZagadnienia.py            | 25 ++++++++++++++++++++++
 src/eig_problem/ParametryMaterialowe.py            |  3 +++
 src/eig_problem/WektorySieciOdwrotnej.py           |  3 +++
 src/eig_problem/ZagadnienieWlasne.py               |  2 ++
 src/eig_problem/ZagadnienieWlasneAntidot.py        |  5 ++++-
 src/fft_from_image/Chain_Generation.py             |  1 +
 src/fft_from_image/Reconstruction.py               |  1 +
 src/fft_from_image/TablicaWartosciPikseli.py       |  4 ++++
 .../DensityPlot.py                                 |  3 +++
 .../Magnetyzacja.py                                | 19 +++++++++++++++-
 .../RdzenKwadratowyKwadratowa.py                   |  3 ++-
 .../RdzenOkraglyKwadratowa.py                      |  2 +-
 .../SiatkaPunktow.py                               |  4 +++-
 .../SiecKwadratowa.py                              |  3 ++-
 .../WektorySieci.py                                |  4 ++++
 src/structure_from_fourier_coefficient/__init__.py |  1 +
 tst/test_eig_problem.py                            |  4 +++-
 tst/test_fft_import_export.py                      |  2 ++
 24 files changed, 141 insertions(+), 13 deletions(-)

diff --git a/poczatek.py b/poczatek.py
index cac7ba0..64c391d 100755
--- a/poczatek.py
+++ b/poczatek.py
@@ -6,6 +6,7 @@ import scipy.special
 
 import matplotlib.pyplot as plt
 
+# That's actually covered in my other comments :).
 
 def wspolczynniki(zakres_x, zakres_y):
     """
@@ -28,7 +29,7 @@ def wspolczynniki(zakres_x, zakres_y):
     wspolczynniki_wektor[int(len(gx) / 2)][int(len(gy) / 2)][2] = MoA * (d ** 2 / s) + MoB * (1 - d ** 2 / s)
     return wspolczynniki_wektor
 
-
+# okragly ;)
 def wspolczynniki_rdzen_okrogly(zakres_x, zakres_y):
     """
     :type zakres_x: współrzędna x-owa wektora G w kwadratowej sieci odwrotnej
@@ -149,4 +150,4 @@ MoA = 10
 MoB = 4
 R = 3
 
-wykres_pcolor(1, 2, 2)
\ No newline at end of file
+wykres_pcolor(1, 2, 2)
diff --git a/src/drawing/Dispersion_graph.py b/src/drawing/Dispersion_graph.py
index 06257cc..66f661f 100755
--- a/src/drawing/Dispersion_graph.py
+++ b/src/drawing/Dispersion_graph.py
@@ -1,6 +1,12 @@
 import matplotlib.pyplot as plt
 import numpy as np
 
+# file names should be consistent in the whole project, so this one should be
+# named DispersionGraph.py (and others should have names in English)
+
+# What name? Who is named 'text.txt'? It's rather a filename, but...  what
+# file? Is it a name of a file with test data? Maybe these lines and the file
+# should be placed in some "tst/" dir? Use proper name here.
 name = 'test.txt'
 """
 m = np.transpose(np.loadtxt(name))[1:]
@@ -8,26 +14,35 @@ m = np.transpose(np.loadtxt(name))[1:]
 num = np.arange(1, np.shape(m)[0] + 1)
 np.savetxt(name, np.transpose([num, m]), fmt='%.0f  %.12e')
 """
+# Do you really need global variable? Is there any error-checking? What if this
+# file doesn't exist?
 file = np.transpose(np.loadtxt(name))
 
 
 def plot_dispersion():
+    # Why 150? You should name this value.
     for i in range(150):
         plt.plot(file[0], file[1 + i], color='r')
+    # it will be nice to store these labels' names as variables
     plt.xlabel('wektor falowy q [m^-1]')
     plt.ylabel('f [Hz]')
     plt.title(name)
+    # There's no much gain from commented out code ;).
+    # If there's a need to use it sometimes, maybe it should be parametrized by
+    # function's arguments?
     #plt.ylim([0.7e10, 1.2e10])
     plt.show()
 
+# It should be wrapped into `if __name__ == '__main__'` block.
 plot_dispersion()
 
 def plot_num_freq():
     plt.plot(file[1], file[0], color='r')
     plt.xlabel('freq')
     plt.ylabel('num')
+    # It's a bit odd that plot is named after filename
     plt.title(name)
     plt.show()
 
-
+# You can turn this command on using program arguments (I mean sys.argv) as well :).
 #plot_num_freq()
diff --git a/src/drawing/PlotTM.py b/src/drawing/PlotTM.py
index 88c7d76..cdab047 100644
--- a/src/drawing/PlotTM.py
+++ b/src/drawing/PlotTM.py
@@ -1,6 +1,9 @@
 import numpy as np
 import matplotlib.pyplot as plt
 
+# I'd rather use a dict here mapping names to filenames and data
+# ...or maybe a separate class
+# you know... with reload() method
 TM4Co = np.transpose(np.loadtxt('TM4_2809_CoPy.txt'))
 TM5Co = np.transpose(np.loadtxt('TM5_2809_CoPy.txt'))
 TM6Co = np.transpose(np.loadtxt('TM6_2809_CoPy.txt'))
@@ -11,9 +14,14 @@ TM6Niav = np.transpose(np.loadtxt('TM6_1369_NiFeav.txt'))
 TM6Coav = np.transpose(np.loadtxt('TM6_841_CoPy_av.txt'))
 
 def idos_struc_comp():
+    # Why 10e7? What's that? Some magic physics constant?
+    # [1] and [0]?? It could be structured in some way, but better would be
+    # placing a comment here with information about meaning of these variables
     plt.plot(TM4Co[1]/10e7, TM4Co[0])
     plt.plot(TM5Co[1]/10e7, TM5Co[0])
     plt.plot(TM6Co[1]/10e7, TM6Co[0])
+
+    # Why [65, 140]? You're using too many magic numbers.
     plt.xlim([65, 140])
     plt.show()
 
@@ -24,5 +32,6 @@ def av_comp():
     plt.show()
 
 
+# Wrap it in `if __name__ == '__main__'`
 av_comp()
-# idos_struc_comp()
\ No newline at end of file
+# idos_struc_comp()
diff --git a/src/drawing/test.py b/src/drawing/test.py
index 804f8b8..f43b985 100755
--- a/src/drawing/test.py
+++ b/src/drawing/test.py
@@ -6,10 +6,13 @@ import matplotlib.pyplot as plt
 import matplotlib.patches as mpatches
 from matplotlib.collections import PatchCollection
 
-
+# Wouldn't a generator expression be better here?
+# (2 * i for i in range(x // 2))
+# And it has a bit strange name :D.
 def rang(x):
     return [2 * i for i in range(x // 2)]
 
+# What if one loading fail?
 file0 = np.loadtxt('0tm5.txt') / 10e9
 file1 = np.loadtxt('1tm5.txt') / 10e9
 file2 = np.loadtxt('0tm6.txt') / 10e9
@@ -24,10 +27,13 @@ ax = plt.gca()
 patches = []
 # add a rectangle
 
-
+# Why [0, 2, 4, 6]?
+# Except that it's simply range(0, a, 2) for a == 7,
+# this list alone means nothing for me.
 for i in [0, 2, 4, 6]:
     tmp = eval('file' + str(i))
     tmp1 = eval('file' + str(i+1))
+    # This for is even more cryptic. What's this 800?
     for j in rang(800 + i*25):
         rect = mpatches.Rectangle((tmp[j], 5*i), (tmp1[j] - tmp[j])*1.01, 10)
         patches.append(rect)
@@ -40,12 +46,17 @@ ax.add_collection(collection)
 plt.ylim([0, 40])
 plt.xlim([1.1, 3])
 ax.axes.get_yaxis().set_visible(False)
+# title == 'tytuł', really :D?
 plt.title('tytuł')
 plt.xlabel('frequency [GHz]')
+# It seems that bbox and style are the same for all these lines. Why didn't you
+# save them in some variable?
 plt.text(1.2, 5, 'TM5', style='italic', bbox={'facecolor':'white', 'alpha':0.4, 'pad':10})
 plt.text(1.2, 15, 'TM6', style='italic', bbox={'facecolor':'white', 'alpha':0.4, 'pad':10})
 plt.text(1.2, 25, 'TM7', style='italic', bbox={'facecolor':'white', 'alpha':0.4, 'pad':10})
 plt.text(1.2, 35, 'TM8', style='italic', bbox={'facecolor':'white', 'alpha':0.4, 'pad':10})
+# tm.svg is a perfect name, if you want to prevent the others from checking
+# your test ;)
 plt.savefig('tm.svg')
 
 
diff --git a/src/eig_problem/DFT.py b/src/eig_problem/DFT.py
index a3511a5..3385b23 100755
--- a/src/eig_problem/DFT.py
+++ b/src/eig_problem/DFT.py
@@ -24,6 +24,20 @@ class DFT(ParametryMaterialowe):
         """
         assert len(wektor) == 2, \
             'form of wektor_q is forbidden. wektor_1 should have two arguments'
+        # For me it looks like a good place for using Factory and Strategy
+        # patterns.
+        # See:
+        # * you've got a way to decide, how this coefficient will be
+        #   calculated: that's dft_factory.get_wspolczynnik_algorithm(wektor)
+        #   method, which could just look for algorithm in some dict
+        #   {(bool, bool) -> func}
+        # * you've got two ways of calcuate it, that's two different subclasses
+        #   of WspolczynnikStrategy
+        #
+        # so these lines would be changed to:
+        #
+        #   algorithm = DftFactory().get_wspolczynnik_algorithm(wektor)
+        #   return algorithm(self.MoA, self.MoB, self.r, self.a)
         if wektor[0] == 0 and wektor[1] == 0:
             return (self.MoA - self.MoB) * np.pi * self.r ** 2 / (self.a ** 2) + self.MoB
         else:
@@ -43,6 +57,7 @@ class DFT(ParametryMaterialowe):
         assert len(wektor) == 2, \
             'form of wektor_q is forbidden. wektor_1 should have two arguments'
 
+        # Same here, it **could** be mix of Factory&Strategy patterns.
         if wektor[0] == 0 and wektor[1] == 0:
             return (self.lA - self.lB) * np.pi * self.r ** 2 / (self.a ** 2) + self.lB
         else:
@@ -57,6 +72,7 @@ class DFT(ParametryMaterialowe):
         :return: Zwraca dwa słowniki. Odpowiednio wektory sieci odwrotnej ze współczynnikami oraz wektory sieci
         odwrotnej z długościami wymiany.
         """
+        # Does it make sense to take a reference to object's own list?
         lista_wektorow = self.lista_wektorow
         dlugosc_wymiany = np.zeros(len(lista_wektorow), dtype=complex)
         wspolczynnik = np.zeros(len(lista_wektorow), dtype=complex)
diff --git a/src/eig_problem/FFTfromFile.py b/src/eig_problem/FFTfromFile.py
index a5c7ffb..079f1a4 100755
--- a/src/eig_problem/FFTfromFile.py
+++ b/src/eig_problem/FFTfromFile.py
@@ -13,6 +13,7 @@ class FFTfromFile:
         """
         :type tab_size: tuple
         """
+        # What if there's no input_fft file?
         self.tmp_table = pd.read_csv(input_fft, delimiter=' ', dtype=float, header=None).values
         re = self.tmp_table[:, 0::2]
         im = self.tmp_table[:, 1::2] * 1j
diff --git a/src/eig_problem/MacierzDoZagadnienia.py b/src/eig_problem/MacierzDoZagadnienia.py
index 261eebb..1b049b8 100755
--- a/src/eig_problem/MacierzDoZagadnienia.py
+++ b/src/eig_problem/MacierzDoZagadnienia.py
@@ -8,12 +8,18 @@ from multiprocessing import Pool
 import numexpr as ne
 
 
+# There's a lot of repetition here, I'd look for a way to limit it
+# Template Method is a good place to start:
+# http://www.oodesign.com/template-method-pattern.html
+# but there is a way better solution, I think.
 class MacierzDoZagadnienia:
     """
     Klasa, w której tworzona jest macierz zagadnienia własnego. Pobiera ona współczynniki Fouriera z klasy FFTfromFile.
     Współczynniki są dla niej tworzone poprzez FFT z pliku graficznego.
     """
 
+    # It seems that there are several groups of arguments - some of them are
+    # connected to each other. Consider wrapping them in a classes.
     def __init__(self, input_fft, rec_vector_x, rec_vector_y, wektor_q, a=ParametryMaterialowe.a, b=ParametryMaterialowe.b,
                  MoA=ParametryMaterialowe.MoA, MoB=ParametryMaterialowe.MoB, lA=ParametryMaterialowe.lA,
                  lB=ParametryMaterialowe.lB, d=ParametryMaterialowe.d,
@@ -33,8 +39,14 @@ class MacierzDoZagadnienia:
         self.shift = np.array([self.rec_vector_x - 1, self.rec_vector_y - 1])
         self.wektor_q = wektor_q
 
+    # Why saving method returns a matrix? It's counterintuitive.
+    # It should save it and, probably, throw some exception on a failure.
     def save_to_file_matrix(self):
         tmp = self.fill_matrix()
+        # Hmm... you could use str.format here:
+        #     np.save(matrix_to_eig_pattern.format(self.rec_vector, tmp.view(float))
+        # ...and check if this file exists before saving - it's reasonable to
+        # create a backup file in that case.
         np.savetxt('matrix_to_eig_TheImpact_' + str(self.rec_vector_x) + ' ' + str(self.rec_vector_x) +
                    '_q=[1e-9,0].txt', tmp.view(float))
         return tmp
@@ -43,13 +55,23 @@ class MacierzDoZagadnienia:
         self.macierz_M = np.zeros((2 * self.ilosc_wektorow, 2 * self.ilosc_wektorow), dtype=complex)
         self.kroneker_delta(self.macierz_M)
         w2 = self.lista_wektorow
+        # I think it would be better to create a Pool() for an object, not for
+        # every call of this method (I mean self.pool = Pool() in __init__)
         pool = Pool()
+        # Oh... tmp<n>?? Why not:
+        #     exchange_field = ...
+        #     static_demagnetizing_field = ...
+        # and so on?
         tmp1 = np.array(pool.map(self.exchange_field, w2))
         tmp4 = np.array(pool.map(self.static_demagnetizing_field, w2))
         tmp2 = np.array(pool.map(self.dynamic_demagnetizing_field_in_plane, w2))
         tmp3 = np.array(pool.map(self.dynamic_demagnetizing_field_out_of_plane, w2))
         self.macierz_M[self.ilosc_wektorow:, 0:self.ilosc_wektorow] += -tmp1 - tmp3 + tmp4
         self.macierz_M[0:self.ilosc_wektorow, self.ilosc_wektorow:] += tmp1 + tmp2 - tmp4
+        # If you need to close it after use, maybe it would be better to put it
+        # in a context manager? What happens when an exception is thrown from
+        # methods above? Is it handled by these methods or propagated to this
+        # one?
         pool.close()
         return self.macierz_M
 
@@ -68,6 +90,7 @@ class MacierzDoZagadnienia:
         tab_from_wektor_1 = np.asfortranarray(
             np.broadcast_to(self.lista_wektorow, (self.ilosc_wektorow , self.ilosc_wektorow, 2)), dtype=int)
         tab_from_vec_l = np.transpose(tab_from_wektor_1, (1, 0, 2))
+        # Oh, these tmps again :).
         tmp = ne.evaluate('tab_from_wektor_1 - tab_from_vec_l + shift')
         tmp1 = self.magnetyzacja[tmp[:, :, 0], tmp[:, :, 1]]
         tmp2 = ne.evaluate('tab_from_vec_l - wektor_2 + shift')
@@ -111,6 +134,8 @@ class MacierzDoZagadnienia:
                    np.exp(-np.linalg.norm(wekt_1 - wekt_2, axis=1) * self.d / 2.)
         tmp3 = wektor_1 - wektor_2 + self.shift
         tmp4 = self.magnetyzacja[tmp3[:, 0], tmp3[:, 1]]
+        # It's the same expression as in
+        # dynamic_demagnetizing_field_in_plane
         return ne.evaluate('tmp1 * tmp2 * tmp4 / H0')
 
 if __name__ == "__main__":
diff --git a/src/eig_problem/ParametryMaterialowe.py b/src/eig_problem/ParametryMaterialowe.py
index 5fc5547..4527e76 100755
--- a/src/eig_problem/ParametryMaterialowe.py
+++ b/src/eig_problem/ParametryMaterialowe.py
@@ -2,6 +2,8 @@ from numpy import pi
 
 
 class ParametryMaterialowe:
+# They are a bit different than some constants and magic numbers in your code,
+# I'd consider loading them from a file
 # Materials
     # Cobalt
     MoCo = 1.14435e6
@@ -41,6 +43,7 @@ class ParametryMaterialowe:
     # amount of reciprocal vectors
     ilosc_wektorow = 729
     # name of output file
+    # output_file :)
     outpu_file = 'test.txt'
 
     def __init__(self):
diff --git a/src/eig_problem/WektorySieciOdwrotnej.py b/src/eig_problem/WektorySieciOdwrotnej.py
index c0de0ac..fe3fed1 100755
--- a/src/eig_problem/WektorySieciOdwrotnej.py
+++ b/src/eig_problem/WektorySieciOdwrotnej.py
@@ -9,6 +9,9 @@ class WektorySieciOdwrotnej:
         self.ilosc_wektorow = rozmiar_macierzy_blok
 
     def lista_wektorow2d(self, typ):
+        # It can be as well good place to use Factory or Strategy pattern
+        # This 'max'/'min' parameter could be argument of __init__ method,
+        # which would create proper strategy object: Max/Min
         assert typ == 'max' or typ == 'min', 'typ should by max or min'
         if typ == 'max':
             indeks = int(sqrt(self.ilosc_wektorow)) - 1
diff --git a/src/eig_problem/ZagadnienieWlasne.py b/src/eig_problem/ZagadnienieWlasne.py
index 3fddeb7..7d3f4a1 100755
--- a/src/eig_problem/ZagadnienieWlasne.py
+++ b/src/eig_problem/ZagadnienieWlasne.py
@@ -65,6 +65,7 @@ class ZagadnienieWlasne(ParametryMaterialowe):
             tmp = [k[0]]
             tmp.extend(self.czestosci_wlasne(k))
             plik.append(tmp)
+        # Error handling?
         np.savetxt(self.outpu_file, plik)
 
     def wektory_wlasne(self):
@@ -82,6 +83,7 @@ class ZagadnienieWlasne(ParametryMaterialowe):
 
 def start():
     # return ZagadnienieWlasne(rozmiar_macierzy_blok, 1, 'DFT', 'II').wektory_wlasne ()
+    # Why 4000?
     return ZagadnienieWlasne(4000, 'FFT').wypisz_czestosci_do_pliku()
 
 if __name__ == "__main__":
diff --git a/src/eig_problem/ZagadnienieWlasneAntidot.py b/src/eig_problem/ZagadnienieWlasneAntidot.py
index 7fc1642..7fbafda 100755
--- a/src/eig_problem/ZagadnienieWlasneAntidot.py
+++ b/src/eig_problem/ZagadnienieWlasneAntidot.py
@@ -12,6 +12,8 @@ class ZagadnienieWlasneAntidot(ZagadnienieWlasne):
         ZagadnienieWlasne.__init__(self, ilosc_wektorow_q, skad_wspolczynnik='FFT')
         self.skad_wspolczynnik = skad_wspolczynnik
 
+        # It's the same as in FFTfromFile, maybe you should move it to a
+        # separate class?
         self.tmp_table = pd.read_csv(self.input_fft, delimiter=' ', dtype=float, header=None).values
         re = self.tmp_table[:, 0::2]
         im = self.tmp_table[:, 1::2] * 1j
@@ -73,6 +75,7 @@ class ZagadnienieWlasneAntidot(ZagadnienieWlasne):
         wektory_wlasne = wektory_wlasne[wartosci_wlasne_index[self.ilosc_wektorow:]]
         return np.savetxt(str(self.lista_wektorow_q[0]) + '.', wektory_wlasne.view(float))
 
+# wrap it in `if __name__ == '__main__'`
 q = ZagadnienieWlasneAntidot(1)
 #q.wektory_wlasne()
-q.wypisz_czestosci_do_pliku()
\ No newline at end of file
+q.wypisz_czestosci_do_pliku()
diff --git a/src/fft_from_image/Chain_Generation.py b/src/fft_from_image/Chain_Generation.py
index 1f6a9a5..b686d86 100644
--- a/src/fft_from_image/Chain_Generation.py
+++ b/src/fft_from_image/Chain_Generation.py
@@ -8,6 +8,7 @@ class Chain_Generation:
         self.num_blocks = num_blocks
         self.repeat = repeat
 
+    # Isn't there any fibbonacci method in one of used librares?
     def fib_number(self):
         n = self.num_blocks
         i = h = 1
diff --git a/src/fft_from_image/Reconstruction.py b/src/fft_from_image/Reconstruction.py
index 1b204f9..9fc2fde 100755
--- a/src/fft_from_image/Reconstruction.py
+++ b/src/fft_from_image/Reconstruction.py
@@ -18,6 +18,7 @@ class Reconstruction:
         plt.show()
 
 
+# I'd rather use a separate file for each class.
 class ReconstructionAngleRotation(Reconstruction):
     def __init__(self, file, angle):
         Reconstruction.__init__(self, file)
diff --git a/src/fft_from_image/TablicaWartosciPikseli.py b/src/fft_from_image/TablicaWartosciPikseli.py
index 48c3e3d..ca46e07 100755
--- a/src/fft_from_image/TablicaWartosciPikseli.py
+++ b/src/fft_from_image/TablicaWartosciPikseli.py
@@ -24,6 +24,10 @@ class TablicaWartosciPikseli(ParametryMaterialowe):
         plik = Image.open(wczytany_plik)
         piksele = [abs((k / 255) - 1) for k in list(plik.getdata(0))]
         rozmiar = plik.size
+        # Is it equivalent of:
+        # tablica_pikseli = [piksele[rozmiar[0] * i:(i+1)]
+        #     for i in range(1, rozmiar[1] + 1)]
+        # ?
         tablica_pikseli = list(zeros(rozmiar[1]))
         for i in range(0, rozmiar[1]):
             tablica_pikseli[i] = piksele[rozmiar[0] * i:(i + 1) * rozmiar[0]]
diff --git a/src/structure_from_fourier_coefficient/DensityPlot.py b/src/structure_from_fourier_coefficient/DensityPlot.py
index 60472e9..a9cac61 100755
--- a/src/structure_from_fourier_coefficient/DensityPlot.py
+++ b/src/structure_from_fourier_coefficient/DensityPlot.py
@@ -16,6 +16,7 @@ class DensityPlot:
         """
         self.lista_magnetyzacja_dla_sieci = lista_magnetyzacja_dla_sieci
 
+    # generowanie_danych_density_plot - strange name, don't you think?
     def generowanie_danych_density_plot(self, k):
         """
         :param k: określa, dla którego z trzech zbiorów danych, współrzędnych x, y, magnetyzacji, tworzona jest tablica.
@@ -45,6 +46,8 @@ class DensityPlot:
         """
         :return: rysowany jest wykres na podstawie danych otrzymanych z metody 'dane_do_wykresu'
         """
+        # You can always do it this, maybe a bit hacky, way:
+        # x, y, z, *_ = self.dane_do_wykresu()
         dane = self.dane_do_wykresu()
         x = dane[0]
         y = dane[1]
diff --git a/src/structure_from_fourier_coefficient/Magnetyzacja.py b/src/structure_from_fourier_coefficient/Magnetyzacja.py
index 2d3e548..45ce8d0 100755
--- a/src/structure_from_fourier_coefficient/Magnetyzacja.py
+++ b/src/structure_from_fourier_coefficient/Magnetyzacja.py
@@ -26,6 +26,13 @@ class Magnetyzacja(object):
         return table
 
     def magnetyzacja_dla_sieci(self, typ_rdzenia):
+        # For me it's rather:
+        #
+        # if typ_rdzenia not in ('kwadratowy', 'okragly'):
+        #     return None
+        # return self.magnetyzacja(self.siec.wylicz_wspolczynniki_fouriera(typ_rdzenia))
+        # 
+        # so this way an error is exceptional situation, not these normal cases
         if typ_rdzenia == 'kwadratowy':
             return self.magnetyzacja(self.siec.wylicz_wspolczynniki_fouriera('kwadratowy'))
         elif typ_rdzenia == 'okragly':
@@ -38,14 +45,24 @@ class Magnetyzacja(object):
         lista = self.siatka_punktow.siatka()[0]
         for ii in range(len(lista)):
             lista[ii][2] = \
+                # Why not lista[ii][:2] (one argument instead of two)?
                 self.magnetyzacja_w_punkcie(parametry, lista[ii][0], lista[ii][1])
         return lista
 
     def magnetyzacja_pod_plot(self, typ_rdzenia):
+        # Do you need this self.siec assignment?
         lista = self.siec
+        # Same as in magnetyzacja_dla_sieci:
+        #
+        # if typ_rdzenia not in ('kwadratowy', 'okragly'):
+        #     return None
+        # return self.mag(self.siec.wylicz_wspolczynniki_fouriera(typ_rdzenia))
+        #
+        # It seems to be a good candidate for some "template method" (you can
+        # pass mag or magnetyzacja function)
         if typ_rdzenia == 'kwadratowy':
             return self.mag(lista.wylicz_wspolczynniki_fouriera('kwadratowy'))
         elif typ_rdzenia == 'okragly':
             return self.mag(lista.wylicz_wspolczynniki_fouriera('okragly'))
         else:
-            return None
\ No newline at end of file
+            return None
diff --git a/src/structure_from_fourier_coefficient/RdzenKwadratowyKwadratowa.py b/src/structure_from_fourier_coefficient/RdzenKwadratowyKwadratowa.py
index 6904bb6..fa3c672 100755
--- a/src/structure_from_fourier_coefficient/RdzenKwadratowyKwadratowa.py
+++ b/src/structure_from_fourier_coefficient/RdzenKwadratowyKwadratowa.py
@@ -6,7 +6,8 @@ import numpy as np
 
 from src.structure_from_fourier_coefficient.Rdzen import Rdzen
 
-
+# You just need RdzenKwadratowy base class, cause all of these
+# RdzenKwadratowy* are the same
 class RdzenKwadratowyKwadratowa(Rdzen):
     def __init__(self, lista_wektorow_b1, lista_wektorow_b2):
         Rdzen.__init__(self, lista_wektorow_b1, lista_wektorow_b2)
diff --git a/src/structure_from_fourier_coefficient/RdzenOkraglyKwadratowa.py b/src/structure_from_fourier_coefficient/RdzenOkraglyKwadratowa.py
index 98c3e3f..2161592 100755
--- a/src/structure_from_fourier_coefficient/RdzenOkraglyKwadratowa.py
+++ b/src/structure_from_fourier_coefficient/RdzenOkraglyKwadratowa.py
@@ -6,7 +6,7 @@ import scipy.special
 
 from src.structure_from_fourier_coefficient.Rdzen import Rdzen
 
-
+# Same as for RdzenKwadratowy - you need RdzenOkragly class
 class RdzenOkraglyKwadratowa(Rdzen):
     def __init__(self, lista_wektorow_b1, lista_wektorow_b2):
         Rdzen.__init__(self, lista_wektorow_b1, lista_wektorow_b2)
diff --git a/src/structure_from_fourier_coefficient/SiatkaPunktow.py b/src/structure_from_fourier_coefficient/SiatkaPunktow.py
index 0c97c36..fe40898 100755
--- a/src/structure_from_fourier_coefficient/SiatkaPunktow.py
+++ b/src/structure_from_fourier_coefficient/SiatkaPunktow.py
@@ -29,6 +29,8 @@ class SiatkaPunktow(object):
         tempx = self.generowanie_punktow(self.zakres_x)
         tempy = self.generowanie_punktow(self.zakres_y)
 
+        # It's common pattern in your code, I'd look for a function in some
+        # library, maybe toolz
         tablica = []
         for ii in tempx:
             temp = []
@@ -44,4 +46,4 @@ class SiatkaPunktow(object):
                 tablica[ii][jj] = [ii, jj, 0]
         return tablica
 
-"""
\ No newline at end of file
+"""
diff --git a/src/structure_from_fourier_coefficient/SiecKwadratowa.py b/src/structure_from_fourier_coefficient/SiecKwadratowa.py
index 7cf07f9..c31e369 100755
--- a/src/structure_from_fourier_coefficient/SiecKwadratowa.py
+++ b/src/structure_from_fourier_coefficient/SiecKwadratowa.py
@@ -5,7 +5,8 @@ from src.structure_from_fourier_coefficient.RdzenOkraglyKwadratowa import RdzenO
 from src.structure_from_fourier_coefficient.Siec import Siec
 from src.structure_from_fourier_coefficient.WektorySieci import WektorySieci
 
-
+# All Siec* classes are the same, you should have one class above them (and it
+# can be Siec with these methods defined
 class SiecKwadratowa(Siec):
     def __init__(self, dlugosc_a1, dlugosc_a2, zakres_wektorow_gx, zakres_wektorow_gy):
         Siec.__init__(self, typ_sieci='kwadratowa')
diff --git a/src/structure_from_fourier_coefficient/WektorySieci.py b/src/structure_from_fourier_coefficient/WektorySieci.py
index de2a5d7..7ac62f3 100755
--- a/src/structure_from_fourier_coefficient/WektorySieci.py
+++ b/src/structure_from_fourier_coefficient/WektorySieci.py
@@ -21,9 +21,13 @@ class WektorySieci(object):
         self.dlugosc_a1 = dlugosc_a1
         self.dlugosc_a2 = dlugosc_a2
         self.kat = kat
+        # Something's wrong here, cause
+        # self.zakres_1 != zakres_1
+        # you should probably use a different name for function argument.
         self.zakres_1 = list(range(-zakres_1, zakres_1 + 1))
         self.zakres_2 = list(range(-zakres_2, zakres_2 + 1))
 
+    # I'd consider using tuples here.
     def wektor_a1(self):
         """
         :return: funkcja zwraca listę z współrzędnymi wektora a1
diff --git a/src/structure_from_fourier_coefficient/__init__.py b/src/structure_from_fourier_coefficient/__init__.py
index 8824eed..4cf33fd 100755
--- a/src/structure_from_fourier_coefficient/__init__.py
+++ b/src/structure_from_fourier_coefficient/__init__.py
@@ -5,6 +5,7 @@ from src.structure_from_fourier_coefficient.Plot import Plot
 from src.structure_from_fourier_coefficient.SiatkaPunktow import SiatkaPunktow
 from src.structure_from_fourier_coefficient.SiecTrojkatna import SiecTrojkatna
 
+# Is this commented out code needed?
 #siatka = SiatkaPunktow(5, 5, 0.07)
 #siec = SiecTrojkatna(10, 10, 18, 18)
 #w = Magnetyzacja(siatka, siec)
diff --git a/tst/test_eig_problem.py b/tst/test_eig_problem.py
index aebe54f..902763a 100755
--- a/tst/test_eig_problem.py
+++ b/tst/test_eig_problem.py
@@ -9,6 +9,8 @@ from src.eig_problem.ParametryMaterialowe import ParametryMaterialowe
 class MacierzDoZagadnieniaTestCases(unittest.TestCase):
 
     def testMatrixtoEignevalue_TheImpact(self):
+        # There are a lot off similar lines here, put these values to variables or
+        # use some kind of "templates"
         tmp = MacierzDoZagadnienia('ff=0.5.dat', 11, 11, np.array([1e-9, 0]), 400e-9, 400e-9,
                                    1.752e6, 0.484e6, 1.09e-17, 5.84e-17,
                                    20e-9, 0, 0.1/(4e-7 * np.pi)).fill_matrix().view(float)
@@ -34,4 +36,4 @@ class MacierzDoZagadnieniaTestCases(unittest.TestCase):
         np.testing.assert_array_almost_equal(tmp, tmp1, decimal=5)
 
 if __name__ == '__main__':
-    unittest.main()
\ No newline at end of file
+    unittest.main()
diff --git a/tst/test_fft_import_export.py b/tst/test_fft_import_export.py
index 1c8cfab..167aa20 100755
--- a/tst/test_fft_import_export.py
+++ b/tst/test_fft_import_export.py
@@ -16,8 +16,10 @@ logging.basicConfig(format='%(levelname)s:%(message)s',
 class TestFFTExportImport(unittest.TestCase):
 
     fft = FFT()
+    # Why 9? Name it.
     fft_from_file = FFTfromFile(9, 'I')
 
+    # It should be parametrized with a path to tst directory.
     def test_export_import(self):
         logging.info("### Running test_export_import...")
         lists_to_export = self.fft.wywolaj_fft(os.path.abspath("./tst/"))
-- 
2.11.1

